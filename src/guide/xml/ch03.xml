<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook"
         xmlns:xi='http://www.w3.org/2001/XInclude'
	 xmlns:xlink="http://www.w3.org/1999/xlink"
	 version="5.0" xml:id="customization">
<info>
  <?db filename="ch-customizing"?>
  <title>Customizing the stylesheets</title>
</info>

<para>In many circumstances, the stylesheets can be used “out of the
box” without any customization. But sometimes you may need to change
the formatting of certain elements. One common reason is to change the
formatting of title pages or navigational features. In other cases, it
may be to support local extensions to DocBook or simply to change the
markup to support a particular use case.</para>

<para>Three approaches are possible, with increasing degrees of
effort: changing stylesheet parameters, creating your own
customization layer, or making broader changes to the stylesheet’s
implementation.</para>

<para>The subject of broader implementation changes is the subject of
<xref linkend="implementation"/>. In this chapter, we’ll look at the
easier options.</para>

<section xml:id="change-params">
<title>Changing stylesheet parameters</title>

<para>The <citetitle>DocBook xslTNG Stylesheets</citetitle> define a
lot of parameters. They are all described in <xref linkend="params"/>.
If the change you want to make has already been parameterized, you may
be able to achieve your goal simply by setting a parameter at runtime.</para>

<para>For example, if you want to change the formatting of dates and times
in <tag>date</tag> elements, you can simply change the
<link linkend="p_date-date-format">date and time formatting</link>
parameters. Similarly, if you want to change the numeration style of
ordered lists, you can simply change the <link
linkend="p_orderedlist-item-numeration">ordered list item
numeration</link> parameter.</para>

<para>These changes can be accomplished by simply passing the new
values to the processor, on the command line or in a configuration
file, for example. You do not have to write any XSLT to make these
changes.</para>

<para>Parameter values apply to the entire document processed by the
stylesheets. In some cases, you may wish to change the presentation of
just one or small number of elements. This can often be accomplished
with a <link linkend="pi_db">db processing instruction</link> in
the source document itself. These customizations can also be
accomplished without writing any XSLT.</para>

<para>If you want to make a change that isn’t supported by a
parameter, or an ad hoc exception that doesn’t have a supporting
processing instruction, you will have to write a customization layer.
(You are invited to submit an issue with your use case if you think it
would be of general interest.)
</para>

<para>You may also find it convenient to write a customization layer
if you want to change several parameters and you find it inconvenient
to pass them all to the processor on every invocation.
</para>
</section>

<section xml:id="layer">
<title>Creating a customization layer</title>

<para>A customization layer is simply an XSLT stylesheet that you
write which extends the DocBook stylesheets. The simplest<footnote><para>Ok,
technically, this stylesheet has a couple of namespace references that aren’t
strictly necessary so it could be a teeny bit simpler, but you’ll need those
declarations (and more!) if you want to do anything useful.</para></footnote> customization
layer is:</para>

<programlisting language="xml"
><xi:include href="examples/custom0.xsl" parse="text"/></programlisting>

<para>This customization doesn’t do anything. But you can, for example, redefine
parameters if you wish:</para>

<programlisting language="xml"
><xi:include href="examples/custom1.xsl" parse="text"/></programlisting>

<para>This will have the effect of running the DocBook stylesheets with those two
parameters set as specified.</para>

<para>If you want to change the HTML output for an element, you can write a template
for that element in your customization layer. Consider this DocBook document:
</para>

<programlisting language="xml"
><xi:include href="examples/sample.xml" parse="text"/></programlisting>

<para>Suppose that you decided you wanted to have the
<tag>productname</tag> element link automatically to the vendor
webpage.</para>

<important>
<para>The <citetitle>DocBook xslTNG Stylesheets</citetitle> process
<emphasis>all</emphasis> DocBook elements in the
<mode>m:docbook</mode> mode. This is different from previous XSLT stylesheets for DocBook
which simply used the default mode.</para>
<para>You must either specify a default mode in your customization layer
or remember to specify the mode on match templates and template applications.
If you forget the mode, you’ll get unexpected results!</para>
</important>

<para>One way to do that would be to redefine the template that processes the
<tag>productname</tag> element:</para>

<programlistingco>
<areaspec>
  <area xml:id="ex.xmlns-m" coords="5 52"/>
  <area xml:id="ex.excl-m" coords="8 40"/>
  <area xml:id="ex.m-docbook" coords="21 34"/>
  <area xml:id="ex.cramped" coords="24 1"/>
  <areaset xml:id="ex.next-match">
    <area xml:id="ex.next-match-44" coords="44 26"/>
    <area xml:id="ex.next-match-48" coords="48 28"/>
  </areaset>
</areaspec>
<programlisting language="xml"
><xi:include href="examples/custom2.xsl" parse="text"
             xpointer="line=0,;length=1559"/></programlisting>
</programlistingco>

<calloutlist>
<callout arearefs="ex.xmlns-m">
<para>All of the DocBook elements are processed in the “<mode>m:docbook</mode>” mode.</para>
</callout>
<callout arearefs="ex.excl-m">
<para>Remember to exclude all the namespaces you declare so that they don’t wind up
scattered about in your HTML.</para>
</callout>
<callout arearefs="ex.m-docbook">
<para>I repeat, all of the DocBook elements are processed in the
“<mode>m:docbook</mode>” mode. I expect failure to declare this mode is going to be a common
error.</para>
</callout>
<callout arearefs="ex.cramped">
<para>Yes, this whole listing is rather cramped.
<phrase outputformat="print">I’m trying to make it all narrow
enough to fit in the display without overflowing the margins.
</phrase><phrase outputformat="online">I’m trying to make it all narrow
enough to fit in the display without making horizontal scrolling necessary.</phrase>
</para>
</callout>
<callout arearefs="ex.next-match">
<para>Calling <literal>xsl:next-match</literal> invokes the underlying
processing. The effect of this template is to wrap an HTML
“<code>a</code>” around the default processing for
<tag>productname</tag>.</para>
</callout>
</calloutlist>

<para>It’s worth pointing out that if the tag has an
<att>xlink:href</att> attribute, that will generate an HTML
<code>a</code> as well. A more robust stylesheet would check for that,
but I’m trying to keep the example simple.</para>

</section>

<section xml:id="managing-css">
<title>Managing CSS stylesheets</title>

<para>The HTML that the <citetitle>DocBook xslTNG</citetitle> stylesheet
produce is intended to be clean, robust markup for styling with CSS.
Exactly how you control which stylesheet links are produced has
changed several times. The current scheme is this:</para>

<orderedlist>
<listitem>
<para>If syntax highlighting is enabled, a link to the
<parameter>verbatim-syntax-highlight-css</parameter> stylesheet is
included.
</para>
</listitem>
<!--
<listitem>
<para>If <parameter>oxy-markup-css</parameter> <glossterm>is
true</glossterm> and there is at least one processing instruction in
the document that has a name that begins with <code>oxy_</code>,
a link to the <parameter>oxy-markup-css</parameter> stylesheet
is included.
</para>
</listitem>
-->
<listitem>
<para>If <parameter>persistent-toc</parameter> <glossterm>is
true</glossterm> 
a link to the <parameter>persistent-toc-css</parameter> stylesheet
is included.
</para>
</listitem>
<listitem>
<para>If <parameter>use-docbook-css</parameter> <glossterm>is true</glossterm>,
links to the standard DocBook stylesheets are included. Those stylesheets
are <filename>docbook.css</filename> (for all media),
<filename>docbook-screen.css</filename> (for screen media), and
<filename>docbook-page-setup.css</filename> and
<filename>docbook-paged.css</filename> (for print media).
</para>
</listitem>
<listitem>
<para>The DocBook element that is the context element when the HTML
<tag namespace="http://www.w3.org/1999/xhtml">head</tag> is being
generated is processed in the <mode>m:html-head-links</mode> mode.
By default, that template does nothing, but you can change that in
a customization layer.</para>
</listitem>
<listitem>
<para>If any CSS stylesheets are defined in
<parameter>user-css-links</parameter>, they are included.
</para>
</listitem>
<listitem>
<para>The DocBook element that is the context element when the HTML
<tag namespace="http://www.w3.org/1999/xhtml">head</tag> is being
generated is processed in the <mode>m:html-head-last</mode> mode.
By default, that template does nothing, but you can change that in
a customization layer.</para>
</listitem>
</orderedlist>
</section>

<section xml:id="media">
<title>Managing media</title>

<para>References to external media through <tag>imagedata</tag>,
<tag>videodata</tag>, <tag>audiodata</tag>, and even
<tag>textdata</tag> can be tricky to manage. On the one hand, it’s
most convenient if the URIs in the source documents point to the
actual media files. This allows extensions, like the image properties
<link linkend="extensions">extension function</link>, to access the
files. At the same time, the references generated in the HTML have to
point to the locations where they will be published. It is often, but
not always, the case that the authoring structures and the publishing
structures are the same.</para>

<para>The stylesheets are regularly tested against five possible
arrangements: three where the media are stored in locations relative
to the XML files and two where the media are stored in a separate
hierarchy. These are unimaginative named “mo-1”, “mo-2”, “mo-3”, “mo-4”,
and “mo-5”.
You can find them in the
<filename xlink:href="https://github.com/docbook/xslTNG/tree/main/src/test/resources/xml"
>src/test/resources/xml</filename> hierarchy in the repository.</para>

<variablelist>
<varlistentry xml:id="mo_mo-1">
<term>mo-1</term>
<listitem>
<para>All of the XML files are in a single directory, the media are in the same
hierarchy. Media references in the source use relative URIs to refer to the
underlying media: <filename>preface.xml</filename> refers to the “this is a test”
audio clip as <uri>media/this-is-a-test.mp3</uri>.
</para>
</listitem>
</varlistentry>
<varlistentry xml:id="mo_mo-2">
<term>mo-2</term>
<listitem>
<para>The XML files are in different directories (this changes the
base URI of the media elements). The media are in the same hierarchy.
Media references in the source use relative URIs to refer to the
underlying media: <filename>front/preface.xml</filename> refers to the “this is a test”
audio clip as <uri>../media/spinning-top.mp4</uri>.
</para>
</listitem>
</varlistentry>
<varlistentry xml:id="mo_mo-3">
<term>mo-3</term>
<listitem>
<para>The XML files are in different directories, but the structure is
deeper. This scenario represents the case where there might be multiple books, each
with their own media, but also a shared media folder “above” the book hierarchies.
The media are in the same hierarchy, but some are “above” the book.
Media references in the source use relative URIs to refer to the
underlying media: <filename>book/front/preface.xml</filename> refers to the “this is a test”
audio clip as <uri>../../media/spinning-top.mp4</uri>.
</para>
</listitem>
</varlistentry>
<varlistentry xml:id="mo_mo-4">
<term>mo-4</term>
<listitem>
<para>The XML files are still in different directories, but the significant change
here is that the media are in their own hierarchy. 
Media references in the source use URIs relative to the root of <emphasis>that</emphasis>
hierarchy: <filename>book/front/preface.xml</filename> refers to the “this is a test”
audio clip as <uri>spinning-top.mp4</uri>.
</para>
</listitem>
</varlistentry>
<varlistentry xml:id="mo_mo-5">
<term>mo-5</term>
<listitem>
<para>The XML files are in different directories and the media are in their own
hierarchy. What’s different here is that the media hierarchy is <emphasis>further</emphasis>
subdivided by media type.
Media references in the source use URIs relative to the root of media
hierarchy <emphasis>without</emphasis> the media type:
<filename>book/front/preface.xml</filename> still refers to the “this is a test”
audio clip as <uri>spinning-top.mp4</uri>, but this time it is found in
<filename>media/mp4/spinning-top.mp4</filename> rather than directly in
<filename>media</filename>.
</para>
</listitem>
</varlistentry>
</variablelist>

<para>For each arrangement, we look at five possible output structures:</para>

<orderedlist>
<listitem xml:id="mo_s-1">
<para>A single HTML document with the media in the same relative locations
as the sources.
</para>
</listitem>
<listitem xml:id="mo_s-2">
<para>A single HTML document with the media in a single <filename>media</filename>
subdirectory.
</para>
</listitem>
<listitem xml:id="mo_s-3">
<para>“Chunked” HTML output with the media in the same relative locations
as the sources.
</para>
</listitem>
<listitem xml:id="mo_s-4">
<para>“Chunked” HTML output with the media in custom locations. (This is especially
tricky for the “mo-5 case because there are two kinds of customization involved.)
</para>
</listitem>
<listitem xml:id="mo_s-5">
<para>“Chunked” HTML output with the media in a single <filename>media</filename>
subdirectory.
</para>
</listitem>
</orderedlist>

<para>The list below gives a brief summary of the parameters used to achieve
the desired results for each combination of input and output arrangements.</para>

<note>
<para>Remember that in each case, the questions are: can the
stylesheets find the media files to query them and are the correct
HTML references produced? Actually copying the media files from where
they are in the source system to where they need to be in the HTML is
“not our problem.”</para>
</note>

<variablelist>
<varlistentry>
<term><link linkend="mo_mo-1">mo-1</link>, <link linkend="mo_mo-2">mo-2</link>, and <link linkend="mo_mo-3">mo-3</link> /
      <link linkend="mo_s-1">scenario 1</link></term>
<listitem>
<para>No parameters are needed, this combination works correctly with the defaults.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mo_mo-1">mo-1</link>, <link linkend="mo_mo-2">mo-2</link>, and <link linkend="mo_mo-3">mo-3</link> /
      <link linkend="mo_s-2">scenario 2</link></term>
<listitem>
<programlisting linenumbering="unnumbered">mediaobject-output-base-uri = "media/"
mediaobject-output-paths = "false"</programlisting>
<para>The output base URI is relative to the “root” of the HTML result.
Setting the output paths to “false” removes intermediate hierarchy from the
image references.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mo_mo-1">mo-1</link>, <link linkend="mo_mo-2">mo-2</link>, and <link linkend="mo_mo-3">mo-3</link> /
      <link linkend="mo_s-3">scenario 3</link></term>
<listitem>
<programlisting linenumbering="unnumbered">chunk = "index.html"
chunk-output-base-uri = "/path/to/output/location/"</programlisting>
<para>These parameters aren’t related to media objects, they just tell
the stylesheets how and where to “chunk” the output.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mo_mo-1">mo-1</link>, <link linkend="mo_mo-2">mo-2</link>, and <link linkend="mo_mo-3">mo-3</link> /
      <link linkend="mo_s-4">scenario 4</link></term>
<listitem>
<programlisting linenumbering="unnumbered">chunk = "index.html"
chunk-output-base-uri = "/path/to/output/location/"</programlisting>
<para>This combination is really the same as the previous except that
it uses a
<link xlink:href="https://github.com/docbook/xslTNG/blob/main/src/test/resources/mo_1_test_4.xsl">custom stylesheet</link>
with a template in the <mode>m:mediaobject-output-adjust</mode> mode
to add an extra level of hierarchy to the output URIs. This is just an
example of arbitrary, custom processing.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mo_mo-1">mo-1</link>, <link linkend="mo_mo-2">mo-2</link>, and <link linkend="mo_mo-3">mo-3</link> /
      <link linkend="mo_s-5">scenario 5</link></term>
<listitem>
<programlisting linenumbering="unnumbered">chunk = "index.html"
chunk-output-base-uri = "/path/to/output/location/"
mediaobject-output-base-uri = "media/"
mediaobject-output-paths = "false"</programlisting>
<para>The output base URI is relative to the “root” of the HTML result.
Setting the output paths to “false” removes intermediate hierarchy from the
image references.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><link linkend="mo_mo-4">mo-4</link> /
      <link linkend="mo_s-1">scenario 1</link></term>
<listitem>
<programlisting linenumbering="unnumbered">mediaobject-input-base-uri = "../media/"</programlisting>
<para>The input base URI will be made absolute relative to the base URI
of the input document, so it’s often convenient to specify it as a relative
URI. It’s equally possible to specify it as an absolute URI.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mo_mo-4">mo-4</link> /
      <link linkend="mo_s-2">scenario 2</link></term>
<listitem>
<programlisting linenumbering="unnumbered">mediaobject-input-base-uri = "../media/"
mediaobject-output-base-uri = "media/"
mediaobject-output-paths = "true"</programlisting>
<para>This example has two images with the same name in different directories,
so it’s necessary to preserve the output paths.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mo_mo-4">mo-4</link> /
      <link linkend="mo_s-3">scenario 3</link></term>
<listitem>
<programlisting linenumbering="unnumbered">chunk = "index.html"
chunk-output-base-uri = "/path/to/output/location/"
mediaobject-input-base-uri = "../media/"</programlisting>
<para>This is the combination of chunking and a single media directory.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mo_mo-4">mo-4</link> /
      <link linkend="mo_s-4">scenario 4</link></term>
<listitem>
<programlisting linenumbering="unnumbered">chunk = "index.html"
chunk-output-base-uri = "/path/to/output/location/"
mediaobject-input-base-uri = "../media/"</programlisting>
<para>This combination is really the same as the previous except that
it uses a
<link xlink:href="https://github.com/docbook/xslTNG/blob/main/src/test/resources/mo_1_test_4.xsl">custom stylesheet</link>
with a template in the <mode>m:mediaobject-output-adjust</mode> mode
to add an extra level of hierarchy to the output URIs. This is just an
example of arbitrary, custom processing.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><link linkend="mo_mo-4">mo-4</link> /
      <link linkend="mo_s-5">scenario 5</link></term>
<listitem>
<programlisting linenumbering="unnumbered">chunk = "index.html"
chunk-output-base-uri = "/path/to/output/location/"
mediaobject-input-base-uri = "../media/"
mediaobject-output-base-uri = "media/"
mediaobject-output-paths = "true"</programlisting>
<para>This is effectively scenario 2 with chunking.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><link linkend="mo_mo-5">mo-5</link> / scenarios 1-5</term>
<listitem>
<para>The “mo-5” scenarios are all the same as the “mo-4” scenarios
with the addition of one more parameter:</para>

<programlisting linenumbering="unnumbered">mediaobject-grouped-by-type = "true"</programlisting>

<para>In each case, this adds the extra “media object type” level to the 
URI path.
</para>
</listitem>
</varlistentry>
</variablelist>

<para>If you download the source repository, you can see these combinations
in action with the build targets
“<literal>mo_<replaceable>number</replaceable>_test_<replaceable>scenario</replaceable></literal>”,
for example, run:</para>

<screen linenumbering="unnumbered">./gradlew mo_3_test_2</screen>

<para>to see the results of processing “mo-3” in scenario 2. The output
will be in the <filename>build/actual</filename> directory. The build target
<buildtarget>all_mo_tests</buildtarget> will run them all.</para>

</section>

<section xml:id="different">
<title>Creating something completely different</title>

<para>Your input documents go through several pre-processing steps
before they are rendered into HTML. If you want to produce completely
different outputs, the place to start is with root template in the
<mode>m:docbook</mode> mode.</para>

<para>Consider, <link xlink:href="https://github.com/docbook/xslTNG/issues/84">for example</link>,
the task of creating a JSON version of the Table of Contents. In principle, you could
write your own stylesheet to do this, but leveraging the
<citetitle>DocBook xslTNG Stylesheets</citetitle> means you can make use of functions like
<function>f:generate-id</function> to create links.</para>

<para>To produce completely different results, override the root template in the
<mode>m:docbook</mode> mode:</para>

<programlisting language="xml"><![CDATA[<xsl:template match="/" mode="m:docbook">
  <xsl:document>
    <!-- your processing here -->
  </xsl:document>
</xsl:template>]]></programlisting>

<para>This template <emphasis>must</emphasis> return a document node.</para>

<para>Note that you can mix-and-match your processing with default
processing by processing DocBook elements in the
<mode>m:docbook</mode> mode.</para>

<para>Here is a simple example of a stylesheet that produces a JSON version of the
Table of Contents for a DocBook document:</para>

<programlisting language="xml"
><xi:include href="examples/issue84.xsl" parse="text"/></programlisting>

<note>
<para>This example is meant as a starting point; it’s not robust as it only handles
a few of the possible elements that might appear in a Table of Contents.</para>
</note>

<para>When processing documents this way, be aware that you are transforming the pre-processed,
normalized versions of your input documents. For example, whether or not you put
<tag>info</tag> wrappers around the titles of your sections, in the pre-processed input,
<tag>title</tag>s <emphasis>always</emphasis> appear inside <tag>info</tag> wrappers.
This normalization greatly simplifies processing in many places.</para>
</section>

</chapter>
